---
title: 安全——ddos
copyright: true
mathjax: true
date: 2020-04-24 21:37:55
tags:
categories:
---

概述：Ddos攻击是目前在互联网中非常常见而且难以解决的网络攻击之一，其**主要方式就是使用控制的僵尸网络来消耗服务器的资源，使服务器不再能够为正常用户提供服务**。大部分的Ddos攻击都会利用**服务器的各种漏洞**以及**基础设施漏洞**的对僵尸网络的**流量进行放大**，从而做到以小搏大的效果，提升攻击的效率。本文对SYN Flood、DNS Query Flood、HTTP Flood等常见的Ddos攻击原理做详解，以及作者的一些理解。

![image](https://raw.githubusercontent.com/AnchoretY/images/master/blog/image.voe30khfd1.png)

<!--more-->

### 1.SYN Flood

&emsp;&emsp;SYN Flood是互联网上最经典的DDoS攻击方式之一，最早出现于1999年左右，雅虎是当时最著名的受害者。SYN Flood攻击利用了TCP三次握手的缺陷，能够以较小代价使目标服务器无法响应，且难以追查。

**标准的TCP三次握手过程如下**：

> &emsp;&emsp;客户端发送一个包含SYN标志的TCP报文，SYN即同步(Synchronize)，同步报文会指明客户端使用的端口以及TCP连接的初始序号;
>
> &emsp;&emsp;服务器在收到客户端的SYN报文后，将返回一个SYN+ACK(即确认Acknowledgement)的报文，表示客户端的请求被接受，同时TCP初始序号自动加1;
>
> &emsp;&emsp;客户端也返回一个确认报文ACK给服务器端，同样TCP序列号被加1。
>
> ![image](https://raw.githubusercontent.com/AnchoretY/images/master/blog/image.qeimqwdakph.png)

&emsp;&emsp;经过这三步，TCP连接就建立完成。TCP协议为了实现可靠传输，在三次握手的过程中设置了一些异常处理机制。**第三步中如果服务器没有收到客户端的最终ACK确认报文，会一直处于SYN_RECV状态，将客户端IP加入等待列表，并重发第二步的SYN+ACK报文。重发一般进行3-5次，大约间隔30秒左右轮询一次等待列表重试所有客户端。另一方面，服务器在自己发出了SYN+ACK报文后，会预分配资源为即将建立的TCP连接储存信息做准备，这个资源在等待重试期间一直保留。**更为重要的是，服务器资源有限，可以维护的SYN_RECV状态超过极限后就不再接受新的SYN报文，也就是拒绝新的TCP连接建立。

&emsp;&emsp;SYN Flood正是利用了上文中TCP协议的设定，达到攻击的目的。**攻击者伪装大量的IP地址给服务器发送SYN报文，由于伪造的IP地址几乎不可能存在，也就几乎没有设备会给服务器返回任何应答了**。因此，服务器将会维持一个庞大的等待列表，不停地重试发送SYN+ACK报文，同时占用着大量的资源无法释放。更为关键的是，**被攻击服务器的SYN_RECV队列被恶意的数据包占满，不再接受新的SYN请求，合法用户无法完成三次握手建立起TCP连接**。也就是说，这个服务器被SYN Flood拒绝服务了。



### 2.DNS Query Flood

&emsp;&emsp;作为互联网最基础、最核心的服务，DNS自然也是DDoS攻击的重要目标之一。打垮DNS服务能够间接打垮一家公司的全部业务，或者打垮一个地区的网络服务。前些时候风头正盛的黑客组织anonymous也曾经宣布要攻击全球互联网的13台根DNS服务器，不过最终没有得手。

{%note info%}

DNS Query Flood的攻击目标为DNS基础设施

{%endnote%}

&emsp;&emsp;UDP攻击是最容易发起海量流量的攻击手段，而且源IP随机伪造难以追查。但过滤比较容易，因为大多数IP并不提供UDP服务，直接丢弃UDP流量即可。所以现在纯粹的UDP流量攻击比较少见了，取而代之的是UDP协议承载的DNS Query Flood攻击。简单地说，越上层协议上发动的DDoS攻击越难以防御，因为协议越上层，与业务关联越大，防御系统面临的情况越复杂。

　　**DNS Query Flood就是攻击者操纵大量傀儡机器，对目标发起海量的域名查询请求。为了防止基于ACL的过滤，必须提高数据包的随机性。常用的做法是UDP层随机伪造源IP地址、随机伪造源端口等参数。在DNS协议层，随机伪造查询ID以及待解析域名。随机伪造待解析域名除了防止过滤外，还可以降低命中DNS缓存的可能性，尽可能多地消耗DNS服务器的CPU资源。**			
				
			

### 3.DNS 反射攻击

&emsp;&emsp;使用DNS反射攻击，攻击者会构造一份请求，**将该请求的发件方填写成为自己想要攻击的目标**，然后将该请求发送给DNS解析服务器，DNS解析服务器受到该请求后会给出相当详尽的响应信息，并通过**庞大的数据包**，将其发送给攻击者想要攻击的地址，从达到攻击者使用较小的带宽来消耗目标服务器较大的带宽。

{%note info%}

发送的 DNS 查询请求数据包大小一般为 60 字节左右，而查询返回结果的数据包大小通常为 3000 字节以上，因此，使用该方式进行放大攻击能够达到 50 倍以上的放大效果。

{%endnote%}

>正常DNS查询：
>&emsp;&emsp;源IP地址 —–DNS查询—-> DNS服务器 —–DNS回复包—-> 源IP地址
>
>DNS反射攻击：
>&emsp;&emsp;伪造IP地址 —–DNS查询—-> DNS服务器 —–DNS回复包—-> 伪造的IP地址（攻击目标）

防御方法：

&emsp;&emsp;1.如果内部有DNS服务器，将DNS服务器设置为只对内部DNS解析请求相应。

&emsp;&emsp;2.限制DNS响应包大小，超过限制大小的数据包直接丢弃。



### 4.HTTP Flood（CC攻击）

&emsp;&emsp;攻击者通过代理或僵尸主机向目标服务器发起大量的HTTP报文，请求涉及数据库操作的URI（Universal Resource Identifier）或其它消耗系统资源的URI，造成服务器资源耗尽，无法响应正常请求。例如门户网站经常受到的HTTP Flood攻击，攻击的最大特征就是选择消耗服务器CPU或内存资源的URI，如具有数据库操作的URI。

**CC攻击的特性：**

> 1.**攻击对象**：一般Ddos都是针对IP进行的拒绝服务，而CC攻击是针对页面进行的拒绝服务。
>
> 2.**攻击发起者**：CC攻击绝大多数都需要使用僵尸网络进行攻击，使用IP也都是真实的肉鸡IP地址。
>
> 2.**请求有效性**：CC攻击的请求都是正常的请求，IP地址也都是正常的IP。
>
> 3.**受到攻击后的表现**:服务器可以正常ping通，但是网页无法访问。



### 5. 慢速攻击

&emsp;&emsp;慢速攻击是CC攻击的一种变体，和CC攻击一样，只要Web服务器开放了Web服务，那么它就可以是一个靶子，HTTP协议在接收到request之前是不对请求内容作校验的，所以即使你的Web应用没有可用的form表单，这个攻击一样有效。

**基本原理：**

&emsp;&emsp;对任何一个开放了HTTP访问的服务器HTTP服务器，先**建立了一个连接，指定一个比较大的content-length，然后以非常低的速度发包，比如1-10s发一个字节，然后维持住这个连接不断开**。如果客户端持续建立这样的连接，那么服务器上可用的连接将一点一点被占满，从而导致拒绝服务。

&emsp;&emsp;**在客户端以单线程方式建立较大数量的无用连接，并保持持续发包的代价非常的低廉**。实际试验中一台普通PC可以建立的连接在3000个以上。这对一台普通的Web server，将是致命的打击。更不用说结合肉鸡群做分布式DoS了。鉴于此**攻击简单的利用程度、拒绝服务的后果、带有逃逸特性**的攻击方式，这类攻击一炮而红，成为众多攻击者的研究和利用对象。

**细分实例：**

&emsp;&emsp;慢速攻击发展到今天，其种类可以分为下面几个种类：

**1.low headers**

&emsp;&emsp;**Web应用在处理HTTP请求之前都要先接收完所有的HTTP头部，因为HTTP头部中包含了一些Web应用可能用到的重要的信息**。攻击者利用这点，发起一个HTTP请求，一直不停的发送HTTP头部，消耗服务器的连接和内存资源。抓包数据可见，**攻击客户端与服务器建立TCP连接后，每30秒才向服务器发送一个HTTP头部，而Web服务器再没接收到2个连续的\r\n时，会认为客户端没有发送完头部，而持续的等等客户端发送数据。**

##### 2.Slow body

&emsp;&emsp;**攻击者发送一个HTTP POST请求，该请求的Content-Length头部值很大，使得Web服务器或代理认为客户端要发送很大的数据。服务器会保持连接准备接收数据，但攻击客户端每次只发送很少量的数据，使该连接一直保持存活，消耗服务器的连接和内存资源**。抓包数据可见，攻击客户端与服务器建立TCP连接后，发送了完整的HTTP头部，POST方法带有较大的Content-Length，然后每10s发送一次随机的参数。服务器因为没有接收到相应Content-Length的body，而持续的等待客户端发送数据。

##### 3.Slow read

&emsp;**&emsp;客户端与服务器建立连接并发送了一个HTTP请求，客户端发送完整的请求给服务器端，然后一直保持这个连接，以很低的速度读取Response**，比如很长一段时间客户端不读取任何数据，通过发送Zero Window到服务器，让服务器误以为客户端很忙，直到连接快超时前才读取一个字节，以消耗服务器的连接和内存资源。抓包数据可见，客户端把数据发给服务器后，服务器发送响应时，收到了客户端的ZeroWindow提示（表示自己没有缓冲区用于接收数据），服务器不得不持续的向客户端发出ZeroWindowProbe包，询问客户端是否可以接收数据。



##### 参考文献

- https://www.jianshu.com/p/dff5a0d537d8

- https://www.cnblogs.com/bonelee/p/9204826.html

  