---
title: Pytorch入门学习心得
date: 2018-09-23 01:18:06
tags: [机器学习,深度学习,Pytorch]
categories: 机器学习
---
全连接
--------



### 1.Dropout

Drop是一种现在在深度学习中使用最为广泛的防止过拟合的方式  

**核心思想**:再训练神经网格时的时候依据概率P保留每个神经元的权重，也就是说每次训练的时候都会有一些神经元被置0，这样就保证神经网络神经网络不会过度学习

**注意**：我们只是在训练的时候使用dropout去使一些神经元不参与训练，但是在预测阶段会使用全部的神经元参与预测

**使用情况**：卷积神经网路只在最后的全连接层中使用dropout，循环神经网络一般只在不同层循环结构体之间使用dropout

### ２.Batch Normalization


**核心思想**：将标准化应用的整个前向传播和反向传播的过程中。传统的标准化一般只是在输入数据之前将数据进行标准化处理，而批标准化是在神经网络的训练过程中对每层的输入数据都进行一个标准化

**使用位置**:线性层和非线性层之间

**作用**：1.加快收敛速度　　2.防止过拟合


​    


### ３.从神经网络角度看线性回归和逻辑回归的区别？  
　　丛神经网络角度上看，逻辑回归只是在线性回归的基础上计入了一层Sigmod激活函数。
　　
　　
　　
　
### ４.全连接网络设计趋势  
**1. 使用线性层和非线性激活函数交替的结果来代替线性层交替的结构往往能大大提升准确率**  
**2. 在线性层和非线性激活函数之间加入批标准化处理加快收敛速度**








CNN
-------

### 卷积层

卷积层可以看作是多个滤波器的集合，**滤波器在深度上要和输入数据保持一致**，让每个滤波器在宽度和深度高度上进行滑动卷积，然后计算整个滤波器和输入数据任意一处的内积，**输出数据的深度和滤波器的个数保持一致**

#### 1.卷积层为什么有效？  

**(1).局部性**  
判断题图片的类型并不是根据整张图片来决定的，而是由一定的局部区域决定的

**(2).相同性**  
对于不同的图片，如果他们属于同一类，他们将具有相同的特征，但这些特征可能属于图片的不同位置，但是在不同位置的检测方式几乎是一样的

**(3).不变性**  
当我们对图片进行下采样时，图片的基本性质不变



#### 2.卷积层的参数
>**关键参数:**  
>　　in_channels ：特征的管道数，彩色图片为3，黑白图片则为1  
>　　out_channels : 输出管道个数，也就是滤波器个数  
>　　kernel_size : 卷积核大小

>**可选参数：**
>　　padding:边界填充0的层数  
>　　stride:步长
>　　bias: 是否使用偏置，默认是True

#### 3.卷积层的输入输出
>**输入：**  
>　　卷积层的输入格式为(batch,channels,width,heights)

>**输出：**  
>　　卷积层的输出取决于输入数据大小W、卷积核大小F、步长S、0填充个数P等四个方面，计算公式如下：  
>　　　　W-F+2P/S + 1


这里在介绍几种常用的卷积层参数设置：

卷积核大小| 0填充层数 | 步长 |卷积层输出
---|---|---|---
3 | 1 | 1 |保持输入维度不变
3 | 0 | 1 |输入维度减2

一般卷积核大小不超过5

#### 4.卷积层的参数共享
基于特征的相同性，因此可以使用相同的滤波器来检测不同位置的相同特征，参数共享共享机制有效的减少卷积层的参数个数，加快了卷积神经网络的训练速度。  

**使用参数共享机制的CNN层参数个数为：**  
　　　**滤波器个数（out_dim） * 神经元大小（kernel_size　* kernel_size * input_dim）**
　　　

例如：当卷积层的的输出是20 * 20 * 32，窗口大小是3 * 3，输入数据深度是10时，当不适用参数共享时神经元个数为20 * 20 * 32，每个神经元个数为3 * 3 * 10，总参数个数为12800 * 900 =11520000个参数。但当我们使用参数共享时，因为输出深度为32，所以存在32个滤波器，每个滤波器存在参数3 * 3 * 10个，而总参数个数即为90 * 32个，大大减少了参数的个数

### 池化层



#### 1.使用池化层有什么作用？
1. 有效的缩小矩阵的尺寸
2. 加快计算速度
3. 防止过拟合

#### 2.池化层的参数设置
>关键参数：  
>　　kernel_size ：池化层的大小

**池化层也可也进行0填充，但是几乎不用**

池化层最常用的池化方式以及参数设置：



池化类型|卷积核大小 | 步长 |池化层输出
---|---|---|---|---
MaxPooling | 2 | 2 |输入维度的一半

**注意：池化层只能改变高度和宽度，不能改变深度；卷积层即可改变数据的宽度和高度也可以改变数据的深度**

### 经典卷积设计的趋向
**1. 使用小滤波器**  
**2. 多个卷积层和非线性激活层交替的结构比单一的卷积层结构能更加有效的提取出更深层次的特征，并且参数个数更少**








RNN
---------

**1.RNN模型的超参数**

>关键参数：  
>　　input_size:输入的维度  
>　　hidden_size：隐藏层维度，也是最终输出的维度  
>　　num_layers: RNN层数  
>可选参数:  
>　　batch_first : 将输入输出的batch放在最前面，顺序为（batch,seq,feature）  
>　　bidirectional: True表示双向循环神经网络，默认为False  
>　　dropout: 参数接受一个0~1之间的一个值，会将网路中出最后一层外加入dropout层

**2.RNN模型的输入**  

RNN模型的输入为:**(seq,batch,feature)**,这里要重点注意，在建立模型时可使用batch_first将顺序变成正常的(batch,seq,feature)．

其中的含义为:
>batch:  样本个数
>
>seq: 每个样本依据附近的样本个数
>
>feature:  每个样本特征数

其实RNN的网络中需要两个输入，上面的序列输入是主要输入，必须进行人工指定，还有一个起始状态输入，可选进行输入，不指定则默认为全0

**3.RNN模型的输出**

RNN的模型输出分为实际输出output和记忆状态h两部分。其中各自的形式和表达如下：

>实际输出output:  
>　　维度：(seq,batch,hidden*direction)  
>记忆状态：  
>　　维度：(layers * direction,bactch,hidden)

>注：使用batch_first可将batch放在最前面
>　　

**4.RNN使用作词性判断**

因为RNN可根据上下文进行输出，因此使用RNN模型根据上下文的词性判断某个词的词性比直接根据该单词判断效果更好。

训练集：
​    输入：给定的句子
​    标签：句子中每个单词的词性

>基本原理：  
>　　首先我们使用word_embedding将句子中的每个词进行词向量化，如：The dog ate apple  转化成4 * word_dim 的词向量  
>　　　　x = x.embedding(x)  
>　　因为lstm需要的输入形式为3维，因此我们要将其转换为1 * 4 * word_dim   
>　　　　x = x.unsqueeze(0)  
>　　再将其输入到lstm模型中，得到模型的实际输出维度为：batch * seq * hidden_dim   
>　　　　output      
>　　因为我们需要判断是的最后一个词的词性，因此我们只需要取最后一个seq就好了  
>　　　　output[:,-1,:]

因为一个单词的词性不只与其上下文关系有关，还与其单词的字母排列情况有关，因此我们可以上面的基础上增加字符角度的lstm来进行表征其字母排列情况。

>完善方案：  
>　　遍历句子The dog ate apple中的每个单词：  
>　　　　将单词中的每个字母进行词向量表示，如apple转化成5 * char_dim的词向量  
>　　　　　　char_info = nn.embedding(x)    
>　　　　将其转换为３维：１* 5 * char_dim  
>　　　　　　char_info = char_info.unsqueeze(0)  
>　　　　将模型输入lstm模型，但这里取记忆状态作为输出,输出状态是h0维度为(1,1,hidden_dim)   
>　　　　　　_,h = char_lstm(char_info)   
>　　　　　　h[0]  
>　　将各个单词的输出组合成一个向量，按照seq进行拼接,形成一个1 * 4 * hidden_dim的向量  
>　　　　for word in words:   
>　　　　　　char_seq = make_sequeece(word,char_to_idx)  
>　　　　　　char_seq = self.char_lstm(char_seq)  
>　　　　　　word_set.append(char_seq)  
>　　　　char = torch.stack(word_set,1)  
> 　根据前面基本方法将单词进行向量化，得到1 * 4 word_dim维向量，将其与字符级别的lstm结果从feature维度进行拼接，得到1 * 4 * char_hidden+word_dim维向量  
>　　　　x = torch.cat((x,char),dim=2)  
>　　最后将两个角度的得到的特征一起输入的最终的lstm模型，在经过全连接层得到最终结果










