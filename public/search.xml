<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>度小满编程记——火车站台问题</title>
    <url>/2019/04/30/%E5%BA%A6%E5%B0%8F%E6%BB%A1%E7%BC%96%E7%A8%8B%E8%AE%B0%E2%80%94%E2%80%94%E7%81%AB%E8%BD%A6%E7%AB%99%E5%8F%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>​    <img src="https://github.com/AnchoretY/images/blob/master/blog/火车站台问题.png?raw=true" alt></p>
<p>​    思路：这道题讲道理如果起点终点没有那么大就很简单了，直接使用字典进行存储，然后选择value最大的那个值即可。而这道题目中明显直接使用上面的思路是行不通了，因此这题使用了一种比较巧的方式，</p>
<p>​    先将各个列车的起点终点分别编码为(站点,编号)，起点编号为-1，终点编号为0，然后从小到大对元组进行排序，然后便利元组列表，如果是终点，那么将维护数+1，如果是起点，那么代表到这里已经有一辆车不再需要维护了，同时记录最大的维护值，便利完全部列表最大的维护值即为结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">train = []</span><br><span class="line">t = <span class="number">0</span></span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">	l = list(map(int,input().split()))</span><br><span class="line">  train.append((l[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">  train.append((l[<span class="number">1</span>],<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">train.sort()   <span class="comment">#这里是关键点，sort函数将对元组进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> train:</span><br><span class="line">  <span class="keyword">if</span> i[<span class="number">1</span>]==<span class="number">0</span>:</span><br><span class="line">    t+=<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    t-=<span class="number">1</span></span><br><span class="line">    ans = max(ans,t)</span><br><span class="line">pritn(ans)</span><br></pre></td></tr></table></figure>
<p>上式中的sort函数对元素为元祖的列表来进行排序，默认规则是先使用元组的第一个元素进行排序，当第一个元素值相同时再使用第二个元素进行排序，下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">-1</span>]]</span><br><span class="line">l.sort()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">	[[<span class="number">1</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">-1</span>], [<span class="number">2</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>在这个问题中使用sort进行排序后，表示由于同一个车站的负值被排在前面，每次先减去1，也就是前一个车一这里为起点，不需要再使用维护。</p>
<p>之前还遇到过好多类似的问题，其实都可以采用这种类似的思路来减少内存占用，比如之前360笔试中遇到过的找</p>
]]></content>
      <tags>
        <tag>机试</tag>
        <tag>算法总结</tag>
      </tags>
  </entry>
</search>
